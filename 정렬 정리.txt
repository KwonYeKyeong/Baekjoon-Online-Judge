1. 선택 정렬(Selection Sort) -> O(n^2) time, O(n) space
 (1) 정렬되지 않은 인덱스의 맨 앞에서부터, 이를 포함한 그 이후의 배열값 중 가장 작은 값을 찾아간다.
 (2) 가장 작은 값을 찾으면, 그 값을 현재 인덱스의 값과 바꿔준다.
 (2) 다음 인덱스에서 위 과정을 반복해준다.

2. 삽입 정렬(Insertion Sort) -> O(n^2) time, O(n) space
 (1) 두번째 인덱스부터 시작. 현재 인덱스는 별도의 변수에 저장해주고, 비교 인덱스를 현재 인덱스 - 1로 잡는다.
 (2) 별도로 저장해 둔 삽입을 위한 변수와, 비교 인덱스의 배열값을 비교한다.
 (3) 삽입 변수의 값이 더 작으면 현재 인덱스로 비교 인덱스의 값을 저장해주고, 비교 인덱스를 -1하여 비교를 반복한다.
 (4) 만약 삽입 변수가 더 크면, 비교 인덱스 + 1에 삽입 변수를 저장한다.

3. 버블 정렬(Bubble Sort) -> O(n^2) time, O(n) space
 (1) 두번째 인덱스부터 시작. 현재 인덱스 값과 바로 이전의 인덱스 값을 비교한다.
 (2) 만약 이전 인덱스가 더 크면, 현재 인덱스와 바꿔준다.
 (3) 현재 인덱스가 더 크면, 교환하지 않고 다음 두 연속된 배열값을 비교한다.
 (4) 이를 (전체 배열의 크기 - 현재까지 순환한 바퀴 수)만큼 반복한다.

4. 합병 정렬(Merge Sort) -> O(NlogN) time, O(n) space

5. 큌 정렬(Quick Sort) -> O(NlogN) time // merge sort보다 대체로 빠름

6. 계수 정렬(Counting Sort) -> O(n) time